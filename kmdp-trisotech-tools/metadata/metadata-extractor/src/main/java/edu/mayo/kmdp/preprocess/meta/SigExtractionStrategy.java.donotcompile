package edu.mayo.kmdp.preprocess.meta;

import com.fasterxml.jackson.databind.JsonNode;
import edu.mayo.kmdp.id.helper.DatatypeHelper;
import edu.mayo.kmdp.metadata.annotations.ObjectFactory;
import edu.mayo.kmdp.metadata.annotations.SimpleAnnotation;
import edu.mayo.kmdp.metadata.surrogate.Dependency;
import edu.mayo.kmdp.metadata.surrogate.KnowledgeArtifact;
import edu.mayo.kmdp.metadata.surrogate.KnowledgeAsset;
import edu.mayo.kmdp.metadata.surrogate.KnowledgeExpression;
import edu.mayo.kmdp.metadata.surrogate.Representation;
import edu.mayo.kmdp.terms.kao.knowledgeassetcategory._1.KnowledgeAssetCategory;
import edu.mayo.kmdp.terms.kao.rel.dependencyreltype._2017._12.DependencyRelType;
import edu.mayo.kmdp.util.JaxbUtil;
import org.omg.spec.api4kp._1_0.identifiers.URIIdentifier;
import org.w3c.dom.Document;
import org.w3c.dom.NodeList;

import java.net.URI;
import java.util.Optional;
import java.util.UUID;

import static edu.mayo.kmdp.id.helper.DatatypeHelper.uri;
import static edu.mayo.kmdp.id.helper.DatatypeHelper.vuri;
import static edu.mayo.kmdp.registry.Registry.KMDP_SURR;
import static edu.mayo.kmdp.registry.Registry.OMG_CMMN;
import static edu.mayo.kmdp.registry.Registry.OMG_CMMN_v11;
import static edu.mayo.kmdp.registry.Registry.OMG_DMN;
import static edu.mayo.kmdp.registry.Registry.OMG_DMN_v11;
import static edu.mayo.kmdp.registry.Registry.W3C_XML;
import static edu.mayo.kmdp.registry.Registry.W3C_XML_v11;
import static edu.mayo.kmdp.util.JSonUtil.jString;
import static edu.mayo.kmdp.util.XMLUtil.asElementStream;
// cao: from kmdp-models/kmdp-utils
import static edu.mayo.kmdp.util.XPathUtil.xList;
import static edu.mayo.kmdp.util.XPathUtil.xNode;
import static edu.mayo.kmdp.util.XPathUtil.xString;


public class SigExtractionStrategy implements ExtractionStrategy {

	private IdentityMapper mapper;

	@Override
	public IdentityMapper getMapper() {
		return mapper;
	}

	public void setMapper( IdentityMapper mapper ) {
		this.mapper = mapper;
	}

	@Override
	public KnowledgeAsset extractXML( Document dox, JsonNode meta ) {

		KnowledgeAsset surr = newSurrogate();

		Optional<Representation> rep = getRepLanguage( dox, false );

		if ( rep.isPresent() ) {
			Representation r = rep.get();
			surr.withExpression( new KnowledgeExpression()
					                     .withResourceId( uri( UUID.randomUUID().toString() ) )
					                     .withRepresentation( rep.get() ) );
			switch ( r.getLanguage().getUri().toString() ) {
				case OMG_CMMN : surr.withCategory( KnowledgeAssetCategory.Plans_Processes_Pathways_And_Protocol_Definitions );
				break;
				case OMG_DMN : surr.withCategory( KnowledgeAssetCategory.Assessment_Predictive_And_Inferential_Models );
				break;
				default:
			}
		}

		//XMLUtil.streamXMLDocument( dox, System.out );
		Optional<String> docId = getArtifactID( dox );
		String head = getVersionTag( dox, meta ).orElse( null );

		Optional<URIIdentifier> resId = getResourceID( dox,
		                                               docId.orElseThrow( IllegalStateException::new ),
		                                               head );

		resId.ifPresent( surr::setResourceId );

		jString( "name", meta ).map( surr::withName );


		/*
		jDate( "creationDate", meta ).map( surr::withCreationDate );

		jNode( "revisionInfos", meta )
				.flatMap( (n) -> jNode( head, n ) )
				.flatMap( (m) -> jDate( "date", m ) )
				.map( surr::withLastChangeDate );

		surr.withCurrentPublicationStatus( trm( "http://purl.org/spar/pso/draft" ) );
		*/


		if ( docId.isPresent() ) {
			if ( surr.getExpression() == null ) {
				surr.withExpression( new KnowledgeExpression() );
			}
			String id = docId.get();
			KnowledgeArtifact doc = new KnowledgeArtifact();
			surr.getExpression().withCarrier( doc );

			doc.withResourceId( uri( id, head ) );

			doc.withMediaType( "application/xml" );
		}


		extractAnnotations( surr, dox );

		resolveDependencies( surr, dox );

		return surr;
	}

	private void resolveDependencies( KnowledgeAsset surr, Document dox ) {
		NodeList refs = xList( dox, "//*[@externalRef]" );
		asElementStream( refs ).filter( (n) -> n.hasAttribute( "xmlns" ) )
		                       .map( (n) -> n.getAttribute( "xmlns" ) )
		                       .filter( mapper::hasIdMapped )
		                       .forEach( (artifactId) ->
			                       mapper.getResourceId( artifactId )
			                             .ifPresent( (resourceId) ->
			                             	surr.withRelated(
			                             			new Dependency().withRel( DependencyRelType.Depends_On )
					                                                .withTgt( new KnowledgeAsset().withResourceId( mapper.associate( surr.getResourceId(),
					                                                                                                 artifactId,
					                                                                                                 DependencyRelType.Depends_On )
					                                                                             )
					                                        ) ) )
		                               ) ;
	}

	private void extractAnnotations( KnowledgeAsset surr, Document dox ) {
		NodeList annos = dox.getElementsByTagNameNS( KMDP_SURR, SimpleAnnotation.class.getSimpleName() );

		JaxbUtil.unmarshall( ObjectFactory.class, SimpleAnnotation.class, annos, JaxbUtil.defaultProperties() ).stream()
		        .filter( SimpleAnnotation.class::isInstance )
		        .map( SimpleAnnotation.class::cast )
		        .filter( (sa) -> sa.getExpr().getLabel().toLowerCase().contains( "concept" ) )
		        .forEach( surr::withSubject );
	}


	@Override
	public Optional<URIIdentifier> getResourceID( Document dox, String artifactId, String versionTag ) {
		URI uri = mapper.ensureId( xString( dox, "//*[@label='knowledgeResourceId']/@uri" ) );
		return Optional.of( DatatypeHelper.uri( uri.toString(), versionTag ) );
	}

	@Override
	public Optional<String> getVersionTag( Document dox, JsonNode meta ) {
		String tag = null;
		if ( meta != null ) {
			tag = meta.get( "headRevision" ).asText();
		} else {
			Optional<String> lang = detectRepLanguage( dox );
			if ( lang.isPresent() ) {
				switch ( lang.get() ) {
					case OMG_CMMN_v11:
						tag = xString( dox, "//*/@sigExtCmmn:revisionNumber" );
						break;
					case OMG_DMN_v11:
						tag = xString( dox, "//*/@sigExtDmn:revisionNumber" );
						break;
				}
			}
		}
		return Optional.ofNullable( tag );
	}

	@Override
	public Optional<String> getArtifactID( Document dox ) {
		Optional<String> lang = detectRepLanguage( dox );

		return lang.map(  (l) -> {
			switch ( l ) {
				case OMG_DMN:
				case OMG_DMN_v11:
					return xString( dox, "//*/@namespace" );
				case OMG_CMMN:
				case OMG_CMMN_v11:
					return xString( dox, "//*/@targetNamespace" );
				default:
					return null;
			}
		} );
	}

	@Override
	public Optional<Representation> getRepLanguage( Document dox, boolean concrete ) {
		if ( xNode( dox,  "//cmmn:definitions" ) != null ) {
			return Optional.of( new Representation()
					                    .withLanguage( vuri( OMG_CMMN, OMG_CMMN_v11 ) )
					                    .withFormat( concrete ? vuri( W3C_XML, W3C_XML_v11 ) : null ) );
		}
		if ( xNode( dox,  "//dmn:definitions" ) != null ) {
			return Optional.of( new Representation()
					                    .withLanguage( vuri( OMG_DMN, OMG_DMN_v11 ) )
					                    .withFormat( concrete ? vuri( W3C_XML, W3C_XML_v11 ) : null ) );
		}
		return Optional.empty();
	}

	public Optional<String> detectRepLanguage( Document dox ) {
		if ( xNode( dox,  "//cmmn:definitions" ) != null ) {
			return Optional.of( OMG_CMMN_v11 );
		}
		if ( xNode( dox,  "//dmn:definitions" ) != null ) {
			return Optional.of( OMG_DMN_v11 );
		}
		return Optional.empty();
	}

	@Override
	public String getMetadataEntryNameForID( String id ) {
		return "Signavio Export/model_" +
				id.substring( id.lastIndexOf( '/' ) + 1, id.lastIndexOf( '.' ) ) +
				"/model_meta.json";
	}



}
